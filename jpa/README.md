# DB 설계 및 JPA 적용 하기

## DB 설계 및 관계 설정 흐름도
![img.png](img.png)


> - 테이블 설계의 경우 상향식 설계 방식을 사용하여 설계 했습니다.


## JPA 적용

> JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 sql을 작성하는 것이 아니라 JPA가 제공하는 API를 사용하면 된다.

### JPA
> - jpa는 java 진영의 orm 기술 표준이다.
> - ORM : 객체 관계 매핑, 객체와 관계형 데이터베이스를 orm 프레임워크가 중간에서 매핑
> - jpa는 application 과 jdbc 사이에서 동작한다.
> - 구현체 : 하이버네이트, eclipselink 등이 있다.

### 사용 이유
> - sql 중심적인 개발에서 객체 중심으로 개발
> - 생산성, 유지보수성에 좋다. -> 칼럼이 추가 되어도 entity만 수정하면 된다.
> - 패러다임의 불일치 해결 -> 상속, 연관관계, 객체 그래프 탐색, == 비교
> - 데이터 접근 추상화와 벤더 독립성

### EntityManagerFactory 
> - 엔티티 매니저 팩토리는 애플리케이션에서 한번만 생성하고 공유해서 사용해야 한다.

### EntityManager
> - 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 crud 할 수있다.
> - 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드 간에 공유하거나 재사용 하면 안된다.
> - jpa를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 변경 할 경우 예외 발생

### 영속성 컨텍스트
> - entity를 영구 저장하는 환경이다.
> - 영속성 컨텍스트는 논리적인 개념이다.
> - 엔티티 매니저를 생성할 때 하나 만들어진다. -> 엔티티 매니저를 통해서 영속성 컨텍스트에 접근 N : 1 관계(스프링의 경우)
> - 생명주기
>> - 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계 없는 새로운 상태
>> - 영속 (managed) : 영속성 컨텍스트에 관리되는 상태
>> - 준영속 (detached) : 영속성 컨텍스트에 저장되었거나 분린된 상태
>> - 삭제 (removed) : 삭제된 상태
> - 특징
>> - 영속성 컨텍스트는 엔티티를 식별자(@id) 값으로 구분한다. 영속 상태는 식별자 값이 반드시 있어야 한다.
>> - 엔티티를 데이터베이스에 반영하는데 이것을 flush라고 한다.
>> - 장점
>>> - 1차캐시
>>> - 동일성 보장
>>> - 트랜잭션을 지원하는 쓰기 지연
>>> - 변경 감지
>>> - 지연 로딩
>> - 플러시 발생 case
>>> - em.flush() 직접 호출
>>> - 트랜잭션 커밋
>>> - jpql 쿼리 실행
>> - 준영속
>>> - 영속 -> 준영속
>>> - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리
>>> - 영속성 컨텍스트가 제공하는 기능을 사용 못함
>>> - 식별자 값을 가지고 있다. (비영속 상태는 식별자 값이 없을 수 있지만 준영속은 영속이 되어진 후의 상태이므로 식별자 값을 가지고 있다.)
>>> - detach, clear, close로 상태 가능

### 엔티티 매핑
> - 객체와 테이블 매핑 : @Entity, @Table
> - 기본 키 매핑 : @Id
> - 필드와 컬럼 매핑 : @Column
> - 연관관계 매핑 : @ManyToOne, @JoinColum
> - Entity
>> - 기본 생성자는 필수다(public, protected 생성자)
>> - final 클래스, enum, interface, inner 클래스에는 사용할 수 없다.
>> - 저장할 필드에 final을 사용하면 안된다.
> - Table
>> - @Table은 엔티티와 매핑할 테이블을 지정한다. 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용한다.
> - 기본키 매핑
>> - identity, sequence, table 방식을 사용한다.


### 연관관계 매핑 기초
> - 객체 연관관계
>> - 객체간의 참조를 통해서 연관 관계를 설정한다. (단방향 관계) -> 참조
> - 테이블 연관 관계
>> - fk 를 사용하여 연관을 갖는다. (양방향 관계) -> 조인
> 방향 관계를 매핑할 때 둘 중 어떤 것을 사용해야 할지는 반대편 관계에 달려 있다.
> - ManyToOne
>> - fetch : 글로벌 페치 전략을 설정한다.
>> - cascade : 영속성 전이 기능을 사용한다.
> - JoinColumn
>> - 외래 키를 매핑할 때 사용한다.
>> - 속성
>>> - name : 매핑할 외래 키 이름(필드명)
> - 연관관계 사용
>> - 조회
>>> - 객체 그래프 탐색(객체 연관관계를 사용한 조회)
>>> - 객체지향 쿼리 사용(JPQL)
> - 연관관계의 주인
>> - 객체에는 양방향 연관관계라는 것이 없다.
>> - 서로 다른 단방향 연관관계 2개를 어플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다.
>> - mappedBy로 연관 관계를 갖으면 읽기 밖에 하지 못한다(주인 아님)
>> - JoinColumn 있는 곳이 주인이다.
> - 양방향 연관관계의 주의점
>> - 양방향 연관관계를 설정시 주인에 값을 입력하지 않으면 데이터베이스에 데이터가 들어가지 않는다.
> #### 예시
>> * Order 클래스와 User 클래스 참조
>> * UserTest 참조


### 다양한 연관관계 매핑
> - 엔티티의 연관관계를 매핑 할 때 고려해야하는 3가지
>> - 다중성
>>> - ManyToOne
>>> - OneToMany
>>> - OneToOne
>>> - ManyToMany
>> - 단방향, 양방향
>>> - 테이블은 외래 키 하나로 조인을 사용해서 양방향으로 쿼리가 가능하지만 방향이라는 개념이 없다.
>>> - 객체는 참조용 필드를 가지고 있는 객체만 조회가 가능하다.
>> - 연관관계의 주인
>>> - 데이터베이스의 외래키를 관리하는 곳이 주인이다.
>>> - 주인이 아니면 mappedBy 속성을 사용하여 주인 필드 이름을 넣어야 한다.
>>> - 일대다 다대일의 경우 항상 다쪽에 외래키가 존재한다.
>> - ManyToMany를 사용하면 안되는 이유 -> JoinTable 방식으로 매핑 되어진다.(각 테이블의 Pk를 주로 사용 한 복합키 형식)
>>> - joinTable에 칼럼을 추가하면 해당 칼럼들을 사용할 수 없다.
>> #### 예시
>>> - shop, category, shopCategory 참조


### 고급 매핑
> - 상속 관계 매핑
>> - ORM 상속 관계 매핑은 객체의 상속 구조와 데이터베이스의 슈퍼타입, 서브타입 관계를 매핑하는 것이다.
>>> - 각각의 테이블로 변환 : 슈퍼, 서브 타입 테이블을 생성하여 조회 할 때 조인을 이용
>>> - 통합 테이블로 변환 : 테이블 하나만 사용
>>> - 서브타입 테이블로 변환 : 서브 타입마다 하나의 테이블을 생성
>> - 조인 전략
>>> - 자식테이블이 부모 테이블의 기본키를 받아서 사용함
>>> - 타입을 구분하는 컬럼이 필요로 하다 (DTYPE) 
>> - 단일 테이블 전략
>>> - 테이블을 하나만 사용한다.
>>> - 자식 엔티티가 매핑한 모든 컬럼은 null을 허용해야 한다.
>>> - 조인이 필요 없으므로 조회 성능이 빠르다.
>> - 구현 클래스마다 테이블 전략
>>> - 서브타입을 구분해서 처리할 때 효과적이다.
>>> - not null 제약 조건을 사용할 수 있다.
> - 복합 키와 식별 관계 매핑
>> - 식별 관계
>>> - 기본키 + 외래 키
>> - 비식별 관계
>>> - 외래키로만 사용
>>> - Mandatory : 필수적 비식별(Not null)
>>> - Optional : 선택적 비식별(null O)
>> - 복합키
>>> - IdClass : DB 친화적
>>> - EmbeddedId : 객체 지향 친화적
>>> - 복합 키는 equals() 와 hashCode를 필수로 구현해야 한다.
>> - 식별, 비식별 관계
>>> - 테이베이스 설계 관점(??)
>>>> - 식별 관계는 부모 테이블의 기본 키를 자식 테이블로 전파 하며 자식 테이블의 기본 키 컬럼이 점점 늘어난다.
>> #### 예시
>>> - 다양한 연관관계 매핑 동일 참조

### 프록시와 연관관계 관리
> - 프록시
>> - 엔티티를 조회시 항상 엔티티가 직접 조회 되지 않는다.
>> - em.find() 사용시 영속성 컨텍스트에 엔티티가 없으면 db 조회
>> - 프록시 객체는 실제 객체에 대한 참조를 보관한다. 실제 객체의 메소드 호출시 프록시 객체 초기화 된다.
>> - 프록시 객체는 처음 사용할 때 한번만 초기화 된다.
>> - 프록시 객체는 상속 받은 객체이다.(타입 체크시 주의 필요)
>> - em.getReference() 호출시 프록시 객체를 받을 수 있으나 영속성 컨텍스트에 있으면 실제 엔티티 반환한다.
> - 즉시 로딩과 지연 로딩
>> - 즉시 로딩
>>> - 즉시 로딩을 최적화 하기 위해 조인 쿼리를 사용
>>> - null 허용시 외부조인 사용 성능 낮아짐
>>> - jpa 는 선택적 관계 면 외부조인, 필수 관계면 내부 조인을 사용
> - jpa 기본 페치 전략
>> - @ManyToOne, @OneToOne: 즉시 로딩(FetchType.EAGER)
>> - @OneToMany, @ManyToMany: 지연 로딩(FetchType.LAZY)
>> - 모든 것에는 지연 로딩을 사용하는 것이 좋다.
> - 즉시 로딩 시 주의점
>> - 2개 이상의 테이블과 1:N 시 데이터가 N * N 이 되어 너무 대용량 데이터가 메모리에 있을 수 있으므로 권장 x
>> - 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다.
>> - jpa는 1 : N 관계를 즉시 로딩할 때 항상 외부 조인을 사용한다.
> - 영속성 전이 (cascade)
>> - 연관된 엔티티도 함께 영속 상태를 만들고 싶으면 사용한다.
>> - persist, remove 시 전이 되지 않고, 플러시 시점에 전이 되어진다.
> - 고아 객체
>> - 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능이다.
>> - 참조가 제거된 엔티티이다.
>> - 다른 곳에서 참조되지 않는 객체여야 하므로 @OneToOne, @OneToMany에서 사용된다.
>> #### 예시
>>> - admin user 참조

#### 값 타입
> - jpa의 데이터 타입을 크게 분류 하면 "엔티티(생물)", "값(수치)" 으로 나눌 수 있다.
> - 값타입의 경우 엔티티의 생명 주기에 의존한다.
> - 값 타입의 경우 공유 되어지지 않는다.
> - 임베디드 타입
>> - @Embeddable : 값 타입을 정의하는 곳에 표시
>> - @Embedded : 값 타입을 사용하는 곳에 표시
> - 값 타입은 같은 값을 여러 엔티티에서 공유하면 안된다.
> - 불변 객체 사용

### N+1
> - 연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다. 이를 N+1 문제라고 한다.
> - fetchtype이 즉시로딩이라서 발생하는 것이 아니다.
> - 발생 이유
>> -  jparepository 에 정의한 인텊에스 메서드를 실행하면 jpa는 메소드 이름을 분석해 -> jpql로 생성하여 실행한다.
>> - jpql은 sql 을 추상화한 객체지향 쿼리 언어로 sql에 종속되지 않고 엔티티 객체와 필드 이름을 가지고 쿼리 한다.
>> - jpql은 연관관계 데이터를 무시하고 해당 엔티티 기준으로 쿼리를 조호한다. 따라서 문제가 발생 하는 것이다.
> - 해결 방안
>> - fetch join
>>> - 한번에 join을 통해서 가져오기에 지연로딩이 안된다.
>>> - 하나의 쿼리문으로 가져오므로 페이징 쿼리가 되지 않는다.
>> - entity graph
>> - subselect
>> - batchsize
>> - querybuilder -> query dsl, mybatis
