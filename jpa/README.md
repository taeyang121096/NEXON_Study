# DB 설계 및 JPA 적용 하기

## DB 설계 및 관계 설정 흐름도
![img.png](img.png)


> - 테이블 설계의 경우 상향식 설계 방식을 사용하여 설계 했습니다.


## JPA 적용

### JPA
> - jpa는 java 진영의 orm 기술 표준이다.
> - ORM : 객체 관계 매핑, 객체와 관계형 데이터베이스를 orm 프레임워크가 중간에서 매핑
> - jpa는 application 과 jdbc 사이에서 동작한다.
> - 구현체 : 하이버네이트, eclipselink 등이 있다.

### 사용 이유
> - sql 중심적인 개발에서 객체 중심으로 개발
> - 생산성, 유지보수성에 좋다. -> 칼럼이 추가 되어도 entity만 수정하면 된다.
> - 패러다임의 불일치 해결 -> 상속, 연관관계, 객체 그래프 탐색, == 비교
> - 데이터 접근 추상화와 벤더 독립성

### EntityManagerFactory 
> - 엔티티 매니저 팩토리는 애플리케이션에서 한번만 생성하고 공유해서 사용해야 한다.

### EntityManager
> - 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 crud 할 수있다.
> - 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드 간에 공유하거나 재사용 하면 안된다.
> - jpa를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 변경 할 경우 예외 발생

### 영속성 컨텍스트
> - entity를 영구 저장하는 환경이다.
> - 영속성 컨텍스트는 논리적인 개념이다.
> - 엔티티 매니저를 생성할 때 하나 만들어진다. -> 엔티티 매니저를 통해서 영속성 컨텍스트에 접근 N : 1 관계(스프링의 경우)
> - 생명주기
>> - 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계 없는 새로운 상태
>> - 영속 (managed) : 영속성 컨텍스트에 관리되는 상태
>> - 준영속 (detached) : 영속성 컨텍스트에 저장되었거나 분린된 상태
>> - 삭제 (removed) : 삭제된 상태
> - 특징
>> - 영속성 컨텍스트는 엔티티를 식별자(@id) 값으로 구분한다. 영속 상태는 식별자 값이 반드시 있어야 한다.
>> - 엔티티를 데이터베이스에 반영하는데 이것을 flush라고 한다.
>> - 장점
>>> - 1차캐시
>>> - 동일성 보장
>>> - 트랜잭션을 지원하는 쓰기 지연
>>> - 변경 감지
>>> - 지연 로딩
>> - 플러시 발생 case
>>> - em.flush() 직접 호출
>>> - 트랜잭션 커밋
>>> - jpql 쿼리 실행
>> - 준영속
>>> - 영속 -> 준영속
>>> - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리
>>> - 영속성 컨텍스트가 제공하는 기능을 사용 못함
>>> - 식별자 값을 가지고 있다. (비영속 상태는 식별자 값이 없을 수 있지만 준영속은 영속이 되어진 후의 상태이므로 식별자 값을 가지고 있다.)
>>> - detach, clear, close로 상태 가능

### 엔티티 매핑
> - 객체와 테이블 매핑 : @Entity, @Table
> - 기본 키 매핑 : @Id
> - 필드와 컬럼 매핑 : @Column
> - 연관관계 매핑 : @ManyToOne, @JoinColum
> - Entity
>> - 기본 생성자는 필수다(public, protected 생성자)
>> - final 클래스, enum, interface, inner 클래스에는 사용할 수 없다.
>> - 저장할 필드에 final을 사용하면 안된다.
> - Table
>> - @Table은 엔티티와 매핑할 테이블을 지정한다. 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용한다.
> - 기본키 매핑
>> - identity, sequence, table 방식을 사용한다.
