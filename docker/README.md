# docker
## docker 개념
> - 컨테이너 기술을 기반으로 한 일종의 가상화 플랫폼이다.
> - 가상화란 물리적 자원인 하드웨어를 효율적으로 활용하기 위해서 하드웨어 공간 위에 가상의 머신을 만드는 기술이다.
> - 컨테이너란 컨테이너가 실행되고 있는 호스트 os의 기능을 그대로 사용하면서 프로세스를 격리해 독립된 환경을 만드는 기술을 뜻한다.
> - 독립된 환경을 만들어서 하드웨어를 효율적으로 활용하는 기술이다.
> - 어플리케이션을 컨테이너라는 격리된 환경에 패키징한다.
>> - 가상화와 컨테이너
>>  - 이미지는 가상 머신이나 컨테이너 또는 프로그램을 실행하는 데 필요한 파일과 라이브러리, 설정 등을 가지고 있는 파일입니다. 이미지는 레이어라는 계층 구조로 이루어져 있는데, 변경 사항이 생기면 새로운 레이어를 추가해서 기록합니다. 이미지 전체를 새로 받지 않고 해당 레이어만 받는 것으로 이미지를 업데이트할 수 있다는 장점이 있지요. 이미지를 실행하면 프로세스, 즉 컨테이너가 됩니다.
>> - 컨테이너
>>  - 이미지의 실행 인스턴스이다.
>>  - 각 컨테이너는 서로 및 호스트 시스템으로부터 격리된다. → 운영체제 수준의 가상화를 통해 이루어진다.
>>  - 코드, 런타임, 시스템 도구, 라이브러리 등 어플리케이션을 실행하는데 필요한 모든 것을 포함한다.
>>  - 어떤 환경에서든 동일하게 동작하도록 하는 오픈 소스 프로젝트이다.
>> - docker image
>>  - 도커 이미지는 어플리케이션과 그 실행에 필요한 모든 파일, 라이브러리, 의존성 환경 설정을 포함하는 불변의 파일이다.
>>  - 이미지는 컨테이너를 실행하기 위한 템플릿 역할을 한다.
>>  - 도커 이미지는 여러 레이어로 구성된다. 각 레이어는 이전 레이어의 변경 사항을 추가합니다. 이미지를 효율적으로 재사용 하며, 저장 공간을 절약 할 수 있게 한다.
>>  - 이미지를 생성하기 위해 도커파일 이라는 텍스트 문서를 사용한다. 이 문서는 이미지를 만드는 단계별 명령어를 포함한다.
>> - docker demon
>>  - 호스트 시스템에서 실행 되는 백그라운드 프로세스로 api 요청을 수신하고 도커 이미지, 컨테이너, 네트워크 볼륨 등의 관리 작업을 진행한다.
>>  - 데몬은 이미지를 빌드하고, 컨테이너를 시작하며, 컨테이너 간의 통신을 관리하고 컨테이너를 분배하는 역할을 한다.
>>- docker volume
>>  - 컨테이너 **삭제의 경우에만 자체 파일 시스템이 사라지게 되는 특성** 때문에, 코드 수정 이후 코드를 실행을 위한 이미지 리빌딩, 컨테이너 리빌딩의 경우 데이터를 저장할 수 없는 상황이 발생하게 된다.
>>  - 볼륨이란 호스트 머신의 폴더이다.
>>      - 볼륨은 도커 컨테이너 내부의 폴더에 매핑 이다.
>>      - 볼륨의 가지는 의미는 컨테이너 내부 폴더와 컨테이너 외부 폴더를 연결하는 것이다.(**로컬폴더와 내부 폴더는 격리되어 있으나 볼륨을 이용해 연결이 가능하도록 만들 수 있다는 의미**)
>>  - 볼륨 종류
>>      - 익명 볼륨
>>          - 익명 볼륨이란 컨테이너가 존재하는 동안에만 실제로 존재하는 볼륨을 의미한다.
>>      - 명명 볼륨
>>          - 명명 볼륨이란 컨테이너가 컨테이너가 종료된 후에도 볼륨이 유지가 되는 것을 의미한다.
>>  - 마운트
>>      - 마운트란 물리적인 장치를 특정 디렉터리에 연결시켜주는 것을 말한다.
>>          - 볼륨 마운트
>>          - 바인드 마운트
>>          - tmfs 마운트
>>  - 볼륨 마운트
>>      - 도커가 생성하고 관리하는 방식이다.
>>      - 즉, 도커에 의해 볼륨이 생성되고 도커에 의해 관리되는 방식으로 볼륨이 로컬 디렉터리에 마운트 될 경우 바인드 마운트와 유사하게 동작한다. 볼륨을 생성하면 자동으로 아래의 경로에 볼륨이 마운트 되어진다. 해당 경로를 마운트 포인트 라고 부른다.(**이때, 도커프로세스가 아닌 non-docker프로세스가 해당 경로에 접근하여 수정하면 안된다.**) 아래의 디렉터리에서 볼륨이 생성되고 관리된다. (즉, 볼륨마운트는 아래의 경로에 볼륨이 생성되고 해당 볼륨을 도커와 연결시켜 관리하는 것이다.)

## docker 명령어
> - docker --version
>   - 도커 버전 확인
> - docker image build -t <이미지명>[:태그명] .(docker file 경로)
>   - 현재 디렉토리에 있는 Dockerfile을 이용하여 이미지 생성
> - docker image pull <이미지명>[:태그명]
>   - 이미지 다운로드
> - docker image ls 
>   - 이미지 목록 확인
> - docker ps 
>   - 실행중인 컨테이너 목록 확인
> - docker ps -a
>   - 모든 컨테이너 목록 확인
> - docker container ls -a 
>   - 전체 컨테이너 목록 확인
> - docker start <컨테이너명>
>   - 컨테이너 시작
> - docker stop <컨테이너명>
>   - 컨테이너 중지
> - docker attach <컨테이너명>
>   - 컨테이너 접속
> - docker run <컨테이너명>
>   - 컨테이너 실행
> - docker run -it <컨테이너명>
>   - 컨테이너 실행 및 접속
> - docker rm <컨테이너명>
>   - 컨테이너 삭제
> - docker exec -it <컨테이너명> /bin/bash
>   - 실행중인 컨테이너에 접속
> - exit
>   - 컨테이너에서 나오기
## Dockerfile
> - 여러가지 명령어를 토대로 Dockerfile을 작성한 후 빌드하면 Docker는 Dockerfile에 나열된 명령문을 차례대로 수행하며DockerImage를 생성한다.
> - 장점
>   - 이미지를 만드는 과정을 자동화 할 수 있다.
>   - 배포에 용이하다.
>   - 이미지를 재사용 할 수 있다.
>   - 이미지를 공유 할 수 있다.
>   - 이미지를 버전 관리 할 수 있다.
>   - 이미지를 빌드하는 과정을 통해 어플리케이션의 빌드 과정을 테스트 할 수 있다.
> - Dockerfile을 작성할 때는 "Dockerfile"이라는 파일명으로 작성해야 한다.
> - Dockerfile의 명령어는 대소문자를 구분하지 않는다.
> ### Dockerfile 명령어
> - FROM
>   - 베이스 이미지를 지정한다.
> - RUN
>   - 이미지를 빌드할 때 실행할 명령어를 지정한다.
> - CMD
>   - 컨테이너가 시작되었을 때 실행할 명령어를 지정한다.
>   - CMD는 Dockerfile에서 한 번만 사용할 수 있다.
>   - 컨테이너를 생성할 때 실행할 명령어를 지정한다.
> - LABEL
>   - 이미지에 메타데이터를 추가한다.
> - EXPOSE
>   - 컨테이너가 사용할 포트를 지정한다.
> - ENV
>   - 환경변수를 설정한다.
> - ADD
>   - 파일을 이미지에 추가한다.
>   - 일반 파일 뿐 아니라 압축파일 네트워크 상의 파일도 사용가능하다.
> - COPY
>   - 파일을 이미지에 추가한다.
>   - 특수한 파일이 아닐 경우 ADD보다 COPY를 사용하는 것이 좋다.
> - ENTRYPOINT
>   - 컨테이너가 시작되었을 때 실행할 명령어를 지정한다.
>   - 컨테이너를 시작할 때마다 실행 한다.
> - VOLUME
>   - 컨테이너와 호스트간의 디렉토리를 공유한다.
>   - 컨테이너가 삭제되어도 데이터는 남아있다.
> - USER
>   - 명령어를 실행할 사용자를 지정한다.
> - WORKDIR
>   - 명령어를 실행할 디렉토리를 지정한다.
> - ARG
>   - 빌드할 때 사용할 변수를 지정한다.
>   - 빌드할 때만 사용할 수 있다.
## docker compose
> - 도커 컴포즈는 시스템 구축과 관련된 명령어를 하나의 파일로 정의하고 한번에 실행할 수 있게 해주는 도구이다.
> - 여러개의 컨테이너를 정의하고 실행할 수 있으며, 컨테이너 간의 의존성을 설정할 수 있다.
> - docker-compose.yml 파일을 작성하여 여러개의 컨테이너를 정의하고 실행할 수 있다.
> - docker compose는 컨테이너 생성 및 삭제만 가능하다. 관리 기능은 없다.
>### Docker Compose 구성 요소
>- **Services**: Docker Compose에서 실행할 컨테이너를 정의한다. 이미지 이름, 컨테이너 이름, 포트, 환경 변수 등의 정보를 포함한다.
>- **Networks**: 각 서비스 간의 네트워크 연결을 정의한다. 이름과 드라이버 등의 정보를 포함한다.
>- **Volumes**: 애플리케이션에서 사용하는 데이터 볼륨을 정의한다. 이름, 드라이버, 옵션 등의 정보를 포함한다.
>- **Environments**: 서비스에서 사용할 환경 변수를 정의한다.
>- **Configuration**: 서비스에서 사용할 환경 설정 파일을 정의한다.
>- **Deployments**: 서비스를 배포하는 데 사용할 설정을 정의한다.
> ### docker compose 명령어
## docker-compose 명령어
>- \-f 옵션
>    - 기본적으로 `docker compose` 명령어는 `docker-compose.yml` 파일이 있는 위치에서 실행해야 한다. 만약 실행 위치에 `docker-compose.yml` 파일이 없거나, 이름이 다르다면 \-f 옵션을 통해 파일 경로를 주어야 한다.
>    - 예시: `docker compose -f ./docker-compose.prod.yml up`
>
>- docker compose build \<service\>
>    - `docker-compose.yml` 파일에서 필요한 이미지들을 찾아서 빌드한다. 따로 서비스를 지정하지 않으면 모든 이미지가 빌드된다.
>
>- docker compose up \<service\>
>    - `docker-compose.yml` 파일에서 서비스에 필요한 모든 컨테이너를 생성하고 시작한다. 만약 컨테이너가 빌드되지 않았거나, 빌드된 이후 도커파일의 변동으로 다시 빌드되어야 하는 경우, 이미지를 빌드한 후 컨테이너를 생성, 시작한다.
>    - 모든 이미지를 새로 빌드해서 컨테이너를 생성하고 싶다면: `docker compose up --build`
>    - 일괄로 중단(stop)하고 싶다면 Ctrl + C
>
>- docker compose down \<service\>
>    - 해당 프로젝트의 컨테이너를 중단하고, 제거한다. network나 volume 또한 제거된다. 단순히 잠시 중단한 뒤 나중에 다시 시작하고 싶다면 `docker compose stop` 혹은 `docker compose`가 실행되고 있는 터미널에서 Ctrl + C를 통해 중단해야 한다.
>
>- docker compose stop \<service\>
>    - 명시한 서비스, 혹은 명시한 서비스가 없다면 전체 컨테이너를 중단한다. down과는 다르게 단순 중단이므로 `start` 명령어로 다시 시작할 수 있다.
>
>- docker compose start \<service\>
>    - 생성된 후에 멈췄던 컨테이너를 시작하는 명령어. 쉽게 말해 `up`을 통해 생성되고, 시작한 이후 `docker compose stop` 혹은 Ctrl + C를 통해 중단된 서비스를 다시 시작할 수 있다.
>
>- docker compose restart \<service\>
>    - `docker compose stop` + `docker compose start`
>    - 만약 build 후 restart를 한다면 직전 생성된 이미지를 사용한다. 따라서 돌아가고 있는 컨테이너의 이미지를 바꿔야 한다면, `docker compose build <service>` 후 `docker compose restart <service>`를 실행한다.
>
>- docker compose ps
>    - 현재 동작하는 컨테이너를 보여준다.
>
>- docker compose logs \<service\>
>    - 해당 서비스의 로그를 보여준다.
>
>- docker exec \<container_id/name\> \<command\>
>    - 현재 돌아가는 컨테이너에 명령어를 전달해준다. 만약 `container_name`을 지정해주지 않았다면, `docker ps`를 통해 `container id`를 먼저 얻어야 한다.
>    - 예시: `docker exec -it <container_id/name> /bin/bash`
>    - 이미지에 따라 `/bin/bash`를 찾을 수 없다고 뜰 수 있다. 특히 `alpine` 이미지에서 이렇게 뜨는 경우가 많은데, 이 때는 `/bin/sh`를 대신 써주면 된다.
>
>- docker exec config \<service\>
>    - 설정 값 등을 보여준다. 환경변수 등이 제대로 들어갔는지 확인하고 싶을 때 사용하면 유용하다.


