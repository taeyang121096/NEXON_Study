# 목적
트랜잭션과 동시성에 대해서 알아보기 위함.


# 프로젝트 주요 환경 구성
> - java 21 -> openjdk 21
> - spring-boot-starter 3.18.0 -> spring 6.x
> - gradle 8.8
> - mysql 8.0.34
> - redis 7.2
> - h2


# 주요 내용
>## 트랜잭션 사용시 이슈
>> - 물리, 논리 트랜잭션 차이
>> - global rollback
>## 동시성 해결 방안
>> - synchronized
>> - x lock
>> - named lock
>> - lettuce lock
>> - redisson lock




# 추가 내용
>## 동기화 메커니즘
> ### 경쟁 조건(Race condition)
>> - 경쟁 조건은 멀티 스레드 프로그램에서 두 개 이상의 스레드가 데이터나 자원에 동시에 접근하려고 할 때 발생하는 문제이다.
>> - 스레들의 실행 순서에 따라 결과가 달라질 수 있다.
>> - 데이터의 일관성 및 정확성을 해칠 수 있다.
>> - 경쟁 조건을 방지 하기 위해 동기화 메커니즘(Lock)을 사용하여 스레드들이 자원에 안전하게 접근 하게 해야 한다.
> ### 임계 영역(Critical section)
>> - 여러 스레드가 동시에 접근해서는 안되는 공유 자원이나 코드를 보호하기 위한 코드 블록을 의미한다.
>> - 데이터 무결성을 유지하며, 경쟁 상태를 방지하는 것이다.
>> - 상호 배제, 진입 조건, 퇴장 조건
> ### LOCK
>> - 여러개의 스레드가 공유 자원에 동시에 접근하는 것을 조절하고 조율 하는데 사용되는 기술이다.(주로 커널에서 사용)
>> #### 스핀락
>>> - 개념 : 락을 획득할 때까지 무한 반복한다.
>>> - 장점 : 단순하고 구현이 쉽다, 락을 기다리는 동안 스레드가 대기하지 않고 계속 실행되므로 일부 상황에서 빠른 응답이 가능하다.
>>> - 단점 : 계속해서 락을 획득할려는 시도 만으로 cpu 자원을 낭비한다.
>>> - 사례 : 실시간 시스템에서는 컨텍스트 스위칭의 오버헤드를 피하기 위해 사용된다. 커널 수준의 동기화에서도 사용된다.
>> #### 뮤텍스
>>> - 개념 : 하나의 스레드가 락을 얻어 임계 영역에 진입 하면, 락을 획득하지 못한 스레드는 락을 가질 수 있을 때까지 휴식한다. 
>>> - 장점 : cpu 자원을 절약합니다,스레드가 여러번 잠글 수 있는 재진입 가능 특성을 가집니다.
>>> - 단점 : 뮤텍스는 잠금을 기다리는 동안 스레드를 블록시키므로 컨텍스트 스위칭이 발생 할 수 있어 비용이 증가한다.
>>> - 사례 : 파일 접근 동기화 와 같이 여러 스레드가 로그 파일에 접근할 때 데이터 무결성을 위해 사용된다.
>> #### 세마포어
>>> - 개념 : 세마포어는 동시에 여러 스레드가 자원에 접근할 수 있도록 허용 할 수 있습니다.
>>> - 장점 : 세마포어는 뮤텍스와 달리 단일 스레드의 소유권 개념이 없으며, 다양한 동기화 문제를 해결하는데 사용할 수 있다.
>>> - 단점 : 설정과 사용이 복잡하다. 초기값 설정을 잘 못 설정 할 경우 데드락이나 자원낭비로 이어질 수 있다.
>>> - 사례 : 리소스 제한 관리 데이터베이스 연결 풀에 동시에 사용할 수 있는 연결의 수를 제한하는데 사용된다.

>## MVCC (Multi Version Concurrency Control)
>> - 하나의 트랜잭션에서 데이터에 접근하는 경우 데이터의 다중버전 상태 중 보장되는 버전에 맞는 값을 반환하여 처리하는 방법을 의미한다.
>> - 데이터를 다중버전 상태로 유지하여 commit 전까지는 이전의 값을 undo 영역에 유지한다.
>### Undo
>> - 되돌리기 위한 변화
>> - 롤백, 읽기 일관성
>> - 멀티 유저의 읽기 일관성을 보호한다.
>> - 최신 데이터를 오래된 데이터로 만들기 위해 존재한다.
>### Redo
>> - 재생하기 위한 변화
>> - 복구
>> - 데이터의 손실을 방지한다.
>> - 오래된 데이터를 최신 데이터로 만들기 위해 존재한다.
>### Oracle, Mysql 접근 방식
>> - 최신 버전의 데이터만 데이터베이스 내에 저장한다.
>> - 이전 데이터는 Undo를 이용하여 데이터를 저장한다.
>> - 각 버전별의 스냅샷을 기준으로 해당 트랜잭션은 해당 스냅샷을 읽도록 해준다.

>## DB Lock
> ### 동시성 제어
>> #### 낙관적 동시성 제어
>>> - 사용자들이 같은 데이터를 동시에 수정하지 않을것이라고 가정
>>> - 데이터를 읽는 시점에 Lock을 걸지 않는 대신 수정 시점에 값이 변경된지를 반드시 검사
>> #### 비관적 동시성 제어
>>> - 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정
>>> - 데이터를 읽는 시점에 Lock을 걸고, 트랜잭션이 완료 될 때 까지 유지
> ### Lock 종류
>> #### 공유 Lock(Shared Lock, Read Lock, S-Lock)
>>> - 공유 Lock은 데이터를 변경하지 않는 읽기 작업을 위해 잠그는 것을 의미한다.
>>> - 다른 세션에서 해당 데이터에 공유 Lock을 걸고 접근 할 수 있다.
>>> - 다른 세션에서 해당 데이터에 배타 Lock을 걸고 접근 할 수 없다.
>> #### 배타 Lock(Exclusive Lock, Write Lock, X-Lock)
>>> - 배타 Lock은 데이터를 변경하는 작업을 위해 잠그는 것을 말한다.
>>> - 다른 세션에서 해당 데이터에 공유 Lock을 걸고 접근할 수 없다.
>>> - 다른 세션에서 해당 데이터에 배타 Lock을 걸고 접근할 수 없다.
>> #### 테이블 Lock
>>> - 테이블 단위로 Lock을 생성 할 수 있다.
>>> - Read는 데이터를 읽을 순 있지만, CUD는 할 수 없다.
>>> - Write는 데이터에 대한 CRUD 작업이 불가능 하다.
>> #### Row Level Lock
>>> - 테이블의 데이터 로우 단위로 Lock 을 생성 할 수 있다.
>>> - 로우 레벨 Lock은 S-Lock, X-Lock을 통해서 설정할 수 있다.
>>> - select * from table for share -> s lock
>>> - select * from table for update -> x lock
>> #### Record lock
>>> - 인덱스가 존재할 경우, 데이터 테이블이 아닌 인덱스 테이블에 Lock이 생성된다.
>> #### gap lock(갭 락)
>>> - 갭락의 범위는 조건에 해당하는 범위 내에서 비어있는 영역을 Lock할 경우에 생성한다.
>> #### next key lock
>>> - 레코드 락과 갭 락을 조합한 것이다.
>>> - 범위에 존재하는 데이터는 레코드 락이 발생하고 존재하지 않는 범위에는 갭락이 생성된다.
>> ### 분산락
>>> - 여러 서버에서 race condition 이 발생할 때, 하나의 공유자원을 충돌이 발생하지 않도록 보유하는 기법이다.
>> #### Named Lock
>>> - 네임드 락은 데이터베이스에 Lock을 획득하여 다른 트랜잭션은 Lock이 해제된 이후에 획득 할 수 있다.
>>> - Connection을 유지해야 하므로 애플리케이션에서 데이터베이스에 connection pool이 부족할 수 있다.
>>> - 별도의 Db를 사용하는게 좋다.
>>> - Connection을 생성한 곳에서만 닫을 수 있다.
>
>## Redis
>>### lettuce
>> #### Lock
>>> - 네임드 락은 실무에서 사용하기엔 connection pool 이슈도 있다.
>>> - 스핀락을 사용하여 동시성을 제어한다.
>>> - 레디스는 싱글 쓰레드로 동작하기에 너무 반복적으로 시도하면 부하만 가중된다.
>> #### 장점
>>> - 비동기 반응형 프로그래밍
>>> - 높은 성능
>>> - 간단한 api
>>> - 스레드 안전성
>> #### 단점
>>> - 분산 락 관리의 제한
>>> - 기능의 제한
>> #### 사용 사례
>>> - 고성능이 필요한 경우
>>> - 단순한 redis 사용
>>> - 비동기 작업
>>### redisson
>> #### Lock
>>> - 레디스 분사락 라이브러리로 다양한 기능을 제공한다.
>>> - Java 언어에 국한된 라이브러리다.
>>> - pub sub 구조를 통해 락을 획득 한다.
>>> - 내부 로직의 경우 스핀락을 사용한다.
>> #### 장점
>>> - 고급 데이터 구조(map, set, list, queue)
>>> - 분산 서비스
>>> - 자동 갱신 및 만료
>> #### 단점
>>> - lettuce 에 비해 성능이 안 좋다.
>>> - 복잡성이 높다.
>> #### 사용 사례
>>> - 고급 분산 기능이 필요한 경우
>>> - 복잡한 데이터 구조 관리 할 경우
